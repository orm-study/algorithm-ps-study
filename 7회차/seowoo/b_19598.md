## 문제 링크
https://www.acmicpc.net/problem/19598


## 접근 과정


## 시간 복잡도

## 코드
```java
import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine());
        int[][] meetings = new int[n][2];

        for (int i = 0; i < n; i++) {
            String[] input = br.readLine().split(" ");
            int start = Integer.parseInt(input[0]);
            int end = Integer.parseInt(input[1]);
            meetings[i][0] = start;
            meetings[i][1] = end;
        }

        Arrays.sort(meetings, (o1, o2) -> o1[0] - o2[0] );

        PriorityQueue<Integer> endPq = new PriorityQueue<>();
        Map<Integer, Integer> endCntMap = new HashMap<>();
        int minMeetingRoom = 0;

        endPq.offer(meetings[0][1]);
        endCntMap.put(meetings[0][1], 1);
        minMeetingRoom += 1;

        for (int i = 0; i < n - 1; i++) {
            int endOfA = meetings[i][1];
            int startOfB = meetings[i + 1][0];
            int endOfB = meetings[i + 1][1];
            if (startOfB < endOfA) {    // A가 끝나고 B를 바로 시작할 수 없다. A와 B는 다른 회의실을 사용한다. 회의실은 새로 만들 수도 있고, 기존에 사용했던 회의실을 재사용할 수도 있다.
                if (checkAvailableMeetingRoom(endPq, startOfB, endOfB, endCntMap) == false) {
                    minMeetingRoom += 1;
                    endPq.offer(endOfB);
                    endCntMap.put(endOfB, endCntMap.getOrDefault(endOfB, 0) + 1);
                }
            } else if (startOfB >= endOfA) {
                endPq.offer(endOfB);
                endCntMap.put(endOfB, endCntMap.getOrDefault(endOfB, 0) + 1);
                endCntMap.put(endOfA, endCntMap.get(endOfA) - 1);
            }
        }

        bw.write(minMeetingRoom + "");
        bw.flush();
    }

    private static boolean checkAvailableMeetingRoom(PriorityQueue<Integer> endPq, int start, int end, Map<Integer, Integer> endCntMap) {
        if (endPq.isEmpty()) return false;
        while (!endPq.isEmpty()) {
            Integer endPeek = endPq.peek();
            if (endPeek > start) return false;
            if (endPeek <= start) {
                Integer endCnt = endCntMap.get(endPeek);
                if (endCnt > 0) {
                    endCntMap.put(endPeek, endCnt - 1);
                    endPq.poll();
                    endPq.offer(end);
                    endCntMap.put(end, endCntMap.getOrDefault(end, 0) + 1);
                    return true;
                } else if (endCnt == 0) {
                    endPq.poll();
                }
            }
        }

        return false;
    }
}

```

## 느낀점
